// DO NOT EDIT THIS FILE !!!!!!! - Saitonya Prera
// WITHOUT TELLING ME
package com.saiton.ccs.commondao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Pattern;
import org.apache.log4j.Logger;
import org.owasp.esapi.ESAPI;
import org.owasp.esapi.codecs.Codec;
import org.owasp.esapi.codecs.OracleCodec;

/**
 * Generic SQL Queries Only to be used by other DAO classes
 *
 * @author Saitonya Prera
 */
public class CommonSqlUtil {

    public static final String EXCEPTION_TAG = " Exception tag --> ";
    public static final String INVALID_SQL = "Invalid sql statement";
    public static final String DB_FAIL = "Databse connection failiure. ";
    public static final String COLUMNTABLE_FAIL
            = "Bad table/column names detected.";
    public static final String NULLPARAM_FAIL = "Null Parameter detected";
    public static final String ANYERROR_FAIL = "Error";
    public static final String MISTMATCH_COLUMN_VAL
            = "Column count and value count mistmatch.";

    private static final Pattern goodColumnOrTable = Pattern.compile(
            "[a-zA-Z_]+");
    private static final Codec oracleCodec = new OracleCodec();

    /**
     * check for SQLi
     *
     * @param columnOrTable
     * @return true if null or bad
     */
    private static boolean isBad(String... columnsOrTables) {

        if (columnsOrTables == null || columnsOrTables.length == 0) {
            return true;
        }

        for (String s : columnsOrTables) {
            //if any string null or bad return true
            if (((s == null) ? true
                    : !goodColumnOrTable.matcher(s).matches())) {
                return true;
            }
        }
        //if nothing is bad return false
        return false;
    }

    /**
     * check for SQLi
     *
     * @param columnOrTable
     * @return true if null or bad
     */
    private static boolean isBadArr(String[] columnsOrTables) {

        if (columnsOrTables == null || columnsOrTables.length == 0) {
            return true;
        }
        for (String s : columnsOrTables) {
            //if any string null or bad return true
            if (((s == null) ? true
                    : !goodColumnOrTable.matcher(s).matches())) {
                return true;
            }
        }
        //if nothing is bad return false
        return false;
    }

    /**
     * Anti SQLi encoding
     *
     * @param s String
     * @return encoded String
     */
    public static String encode(String s) {
        return ESAPI.encoder().encodeForSQL(oracleCodec, s);
    }

    /**
     * Generate an Id for given table
     *
     * @param con Connection object
     * @param columnAutoId column name of auto incremented unique id
     * @param columnPk column name of primary key (must be a string)
     * @param tableName table name
     * @param pkPrepend prepend text : ex CUS (must match for table)
     * @param log Logger to log errors (cannot be null)
     *
     * @return generated id or null if failed
     */
    public static String generateId(Connection con, String columnAutoId,
            String columnPk, String tableName, String pkPrepend, Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(columnAutoId, columnPk, tableName, pkPrepend)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        }

        // select max(id) as ID from customer
        final String getMaxIdQuery = String.format(
                "SELECT MAX(%s) as ID FROM %s LIMIT 1;",
                columnAutoId, tableName);

        // select cus_id from customer where id=?
        final String getPkQuery = String.format(
                "SELECT %s FROM %s WHERE %s=? LIMIT 1",
                columnPk, tableName, columnAutoId);

        Integer id = null;
        String eid = null;
        try {
            PreparedStatement pstmt = con.
                    prepareStatement(getMaxIdQuery);

            ResultSet r = pstmt.executeQuery();

            if (r.first()) {
                id = r.getInt(columnAutoId);
            }

            r.close();
            pstmt.close();

            //get primary key of max auto id
            PreparedStatement pstmtId = con.prepareStatement(
                    getPkQuery);

            pstmtId.setInt(1, id);

            ResultSet rss = pstmtId.executeQuery();
            if (rss.first()) {
                eid = rss.getString(columnPk);
            }
            rss.close();
            pstmtId.close();

            //format and return pk string
            int i = 1;
            if (id != null && eid != null && id != 0) {
                String original = eid.replace(pkPrepend, "");
                i = Integer.parseInt(original) + 1;
                if (i >= 9999) {
                    log.error(EXCEPTION_TAG + "id max reached");
                }
            }

            return String.format("%s%04d", pkPrepend, i);

        } catch (NumberFormatException e) {
            log.error(EXCEPTION_TAG + "Invalid number found in current id");
        } catch (SQLException e) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
            e.printStackTrace();
        }
        return null;
    }

    /**
     * get a list of strings from a table
     *
     * @param con Connection object
     * @param table table name
     * @param getColumn column name to read
     * @param whereColumn1
     * @param equalsTo1
     * @param whereColumn2
     * @param equalsTo2
     * @param log Logger to log errors (cannot be null)
     *
     * @return ArrayList if success else null
     */
    public static ArrayList<String> genericSelectStrings(Connection con,
            String table,
            String getColumn, String whereColumn1, String equalsTo1,
            String whereColumn2, String equalsTo2, Logger log) {

        ArrayList<String> selectedData = new ArrayList<>();

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, getColumn, whereColumn1, whereColumn2)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (equalsTo1 == null || equalsTo2 == null) {
            log.error(EXCEPTION_TAG + NULLPARAM_FAIL);
            return null;
        }

        try {
            final String query = String.format(
                    "SELECT %s FROM %s WHERE %s=? AND %s=?;",
                    getColumn, table, whereColumn1, whereColumn2);
            PreparedStatement stm = con.prepareStatement(query);
            stm.setString(1, encode(equalsTo1));
            stm.setString(2, encode(equalsTo2));
            ResultSet rs = stm.executeQuery();

            while (rs.next()) {
                String v = rs.getString(getColumn);
                selectedData.add(v);
            }

            rs.close();
            stm.close();

            return selectedData;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * get a list of strings from a table
     *
     * @param con Connection object
     * @param table table name
     * @param getColumn column name to read
     * @param whereColumn
     * @param equalsTo
     * @param log Logger to log errors (cannot be null)
     *
     * @return ArrayList if success else null
     */
    public static ArrayList<String> genericSelectStrings(Connection con,
            String table,
            String getColumn, String whereColumn, String equalsTo, Logger log) {

        ArrayList<String> selectedData = new ArrayList<>();

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, getColumn, whereColumn)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (equalsTo == null) {
            log.error(EXCEPTION_TAG + NULLPARAM_FAIL);
            return null;
        }

        try {
            final String query = String.format("SELECT %s FROM %s WHERE %s=?",
                    getColumn, table, whereColumn);
            PreparedStatement stm = con.prepareStatement(query);
            stm.setString(1, encode(equalsTo));
            ResultSet rs = stm.executeQuery();

            while (rs.next()) {
                String v = rs.getString(getColumn);
                selectedData.add(v);
            }

            rs.close();
            stm.close();

            return selectedData;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * get a list of strings from a table
     *
     * @param con Connection object
     * @param table table name
     * @param getColumn column name to read
     * @param log Logger to log errors (cannot be null)
     *
     * @return ArrayList if success else null
     */
    public static ArrayList<String> genericSelectStrings(Connection con,
            String table,
            String getColumn, Logger log) {

        ArrayList<String> selectedData = new ArrayList<>();

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, getColumn)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        }

        try {
            final String query = String.format("SELECT %s FROM %s;",
                    getColumn, table);
            PreparedStatement stm = con.prepareStatement(query);

            ResultSet rs = stm.executeQuery();

            while (rs.next()) {
                String v = rs.getString(getColumn);
                selectedData.add(v);
            }

            rs.close();
            stm.close();

            return selectedData;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * get a list of strings from a table
     *
     * @param con Connection object
     * @param table table name
     * @param getColumn column names to read
     * @param log Logger to log errors (cannot be null)
     *
     * @return ArrayList if success else null
     */
    public static ArrayList<ArrayList<String>> genericSelectStrings(
            Connection con,
            String table,
            String getColumn[], Logger log) {

        ArrayList<ArrayList<String>> selectedData = new ArrayList<>();

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table) || isBadArr(getColumn)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        }

        try {
            final String query = String.format("SELECT %s FROM %s;",
                    String.join(",", getColumn), table);
            PreparedStatement stm = con.prepareStatement(query);

            ResultSet rs = stm.executeQuery();

            while (rs.next()) {
                ArrayList<String> dat = new ArrayList<>();
                for (String clm : getColumn) {
                    String v = rs.getString(clm);
                    dat.add(v);
                }

                selectedData.add(dat);
            }

            rs.close();
            stm.close();

            return selectedData;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * get a string from a table
     *
     * @param con Connection object
     * @param table table name
     * @param getColumn column name to read
     * @param whereColumn1
     * @param equalsTo1
     * @param whereColumn2
     * @param equalsTo2
     * @param log Logger to log errors (cannot be null)
     *
     * @return String if success else null
     */
    public static String genericSelectString(
            Connection con,
            String table,
            String getColumn, String whereColumn1, String equalsTo1,
            String whereColumn2, String equalsTo2, Logger log) {

        String selectedData = "";

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, getColumn, whereColumn1, whereColumn2)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (equalsTo1 == null || equalsTo2 == null) {
            log.error(EXCEPTION_TAG + NULLPARAM_FAIL);
            return null;
        }
        try {
            final String query = String.format(
                    "SELECT %s FROM %s WHERE %s=? AND %s=? LIMIT 1;",
                    getColumn, table, whereColumn1, whereColumn2);
            PreparedStatement stm = con.prepareStatement(query);
            stm.setString(1, encode(equalsTo1));
            stm.setString(2, encode(equalsTo2));
            ResultSet rs = stm.executeQuery();

            if (rs.first()) {
                String v = rs.getString(getColumn);
                selectedData = v;
            }

            rs.close();
            stm.close();

            return selectedData;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
            ex.printStackTrace();
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
            e.printStackTrace();
        }
        return null;
    }

    /**
     * get a string from a table
     *
     * @param con Connection object
     * @param table table name
     * @param getColumn column name to read
     * @param whereColumn
     * @param equalsTo
     * @param log Logger to log errors (cannot be null)
     *
     * @return String if success else null
     */
    public static String genericSelectString(
            Connection con, String table, String getColumn, String whereColumn,
            String equalsTo, Logger log) {

        String selectedData = "";

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, getColumn, whereColumn)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (equalsTo == null) {
            log.error(EXCEPTION_TAG + NULLPARAM_FAIL);
            return null;
        }
        try {
            final String query = String.format(
                    "SELECT %s FROM %s WHERE %s=? LIMIT 1;",
                    getColumn, table, whereColumn);
            PreparedStatement stm = con.prepareStatement(query);
            stm.setString(1, encode(equalsTo));
            ResultSet rs = stm.executeQuery();

            if (rs.first()) {
                String v = rs.getString(getColumn);
                selectedData = v;
            }

            rs.close();
            stm.close();

            return selectedData;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * Check Existence
     *
     * @param con Connection
     * @param table Table Name
     * @param whereColumn Where Column Name
     * @param equalsTo Equals String
     * @param log Logger ! Cannot be null
     * @return null if failed, else existence
     */
    public static Boolean genericCheckExistence(
            Connection con, String table, String whereColumn,
            String equalsTo, Logger log) {

        Boolean exists = null;
        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, whereColumn)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (equalsTo == null) {
            log.error(EXCEPTION_TAG + NULLPARAM_FAIL);
            return null;
        }
        try {
            final String query = String.format(
                    "SELECT EXISTS( SELECT 1 FROM %s WHERE %s = ? LIMIT 1 );",
                    table, whereColumn);
            PreparedStatement stm = con.prepareStatement(query);
            stm.setString(1, encode(equalsTo));
            ResultSet rs = stm.executeQuery();

            if (rs.first()) {
                exists = rs.getBoolean(1);
            }

            rs.close();
            stm.close();

        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return exists;
    }

    /**
     * Generic insert query
     *
     * @param con Connection
     * @param table table name
     * @param setColumns columns list
     * @param values values list
     * @param log Logger (cannot be null)
     *
     * @return null if failed or true if success
     */
    public static Boolean genericInsert(
            Connection con, String table, String[] setColumns, String[] values,
            Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table) || isBadArr(setColumns)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (setColumns.length != values.length) {
            log.error(EXCEPTION_TAG + MISTMATCH_COLUMN_VAL);
            return null;
        }

        final StringBuilder sb = new StringBuilder("?");

        for (int i = 1; i < values.length; i++) {
            sb.append(",?");
        }

        final String insertQuery = String.format(
                "INSERT INTO %s (%s) VALUES (%s);", table, String.join(",",
                        setColumns), sb.toString());
        try {
            PreparedStatement stm = con.prepareStatement(insertQuery);
            for (int j = 0; j < values.length; j++) {
                stm.setString(j + 1, encode(values[j]));
            }
            boolean b = (stm.executeUpdate() > 0);
            stm.close();
            return b;
        } catch (SQLException ex) {
            ex.printStackTrace();
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * Generic insert query, on duplicate key update
     *
     * @param con Connection
     * @param table table name
     * @param setColumns columns list
     * @param values values list
     * @param onUpdColumn
     * @param onUpdValue
     * @param log Logger (cannot be null)
     *
     * @return null if failed or true if success
     */
    public static Boolean genericInsertUpdate(
            Connection con, String table, String[] setColumns, String[] values,
            String onUpdColumn, String onUpdValue,
            Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, onUpdColumn) || isBadArr(setColumns)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (setColumns.length != values.length) {
            log.error(EXCEPTION_TAG + MISTMATCH_COLUMN_VAL);
            return null;
        }

        final StringBuilder sb = new StringBuilder("?");

        for (int i = 1; i < values.length; i++) {
            sb.append(",?");
        }

        final String insertQuery = String.format(
                "INSERT INTO %s (%s) VALUES (%s) ON DUPLICATE KEY UPDATE %s=?;",
                table, String.join(",",
                        setColumns), sb.toString(), onUpdColumn);

        try {
            PreparedStatement stm = con.prepareStatement(insertQuery);
            for (int j = 0; j < values.length; j++) {
                stm.setString(j + 1, encode(values[j]));
            }
            stm.setString(values.length + 1, encode(onUpdValue)); //last value is upd column
            boolean b = (stm.executeUpdate() > 0);
            stm.close();
            return b;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * Generic insert query, on duplicate key update
     *
     * @param con Connection
     * @param table table name
     * @param setColumns columns list
     * @param values values list
     * @param onUpdColumns
     * @param onUpdValues
     * @param log Logger (cannot be null)
     *
     * @return null if failed or true if success
     */
    public static Boolean genericInsertUpdate(
            Connection con, String table, String[] setColumns, String[] values,
            String[] onUpdColumns, String[] onUpdValues,
            Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table) || isBadArr(setColumns)
                || isBadArr(onUpdColumns)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if ((setColumns.length != values.length)
                || (onUpdColumns.length != onUpdValues.length)) {
            log.error(EXCEPTION_TAG + MISTMATCH_COLUMN_VAL);
            return null;
        }

        final StringBuilder sb = new StringBuilder("?");

        for (int i = 1; i < values.length; i++) {
            sb.append(",?");
        }

        final String insertQuery = String.format(
                "INSERT INTO %s (%s) VALUES (%s) ON DUPLICATE KEY UPDATE %s;",
                table, String.join(",",
                        setColumns), sb.toString(), String.join("=?,",
                        onUpdColumns) + "=?");
        
        try {
            PreparedStatement stm = con.prepareStatement(insertQuery);
            for (int j = 0; j < values.length; j++) {
                stm.setString(j + 1, encode(values[j]));
            }
            for (int k = 0; k < onUpdValues.length; k++) {
                stm.setString(k + values.length + 1, encode(
                        onUpdValues[k]));
            }

            boolean b = (stm.executeUpdate() > 0);
            stm.close();

            return b;
        } catch (SQLException ex) {
            ex.printStackTrace();
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            e.printStackTrace();
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * Generic insert query
     *
     * @param con Connection
     * @param table table name
     * @param setColumns columns list
     * @param values values list
     * @param log Logger (cannot be null)
     *
     * @return null if failed or true if success
     */
    public static Integer genericInsertAutoInc(
            Connection con, String table, String[] setColumns, String[] values,
            Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table) || isBadArr(setColumns)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        } else if (setColumns.length != values.length) {
            log.error(EXCEPTION_TAG + MISTMATCH_COLUMN_VAL);
            return null;
        }

        final StringBuilder sb = new StringBuilder("?");

        for (int i = 1; i < values.length; i++) {
            sb.append(",?");
        }

        final String insertQuery = String.format(
                "INSERT INTO %s (%s) VALUES (%s);", table, String.join(",",
                        setColumns), sb.toString());
        try {
            PreparedStatement stm = con.prepareStatement(insertQuery,
                    Statement.RETURN_GENERATED_KEYS);
            for (int j = 0; j < values.length; j++) {
                stm.setString(j + 1, encode(values[j]));
            }
            boolean b = (stm.executeUpdate() > 0);

            ResultSet rs = stm.getGeneratedKeys();
            rs.next();
            int auto_id = rs.getInt(1);
            stm.close();
            rs.close();
            return auto_id;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            e.printStackTrace();
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * generate a insert query (this one is better than generic insert)
     *
     * @param table table name
     * @param setColumns columns list
     *
     * @return null if failed or true if success
     */
    public static String buildQueryStringInsert(
            String table, String[] setColumns) {

        if (isBad(table) || isBadArr(setColumns)) {
            return null;
        }

        final StringBuilder sb = new StringBuilder("?");

        for (int i = 1; i < setColumns.length; i++) {
            sb.append(",?");
        }

        final String insertQuery = String.format(
                "INSERT INTO %s (%s) VALUES (%s);", table, String.join(",",
                        setColumns), sb.toString());

        return insertQuery;
    }

    /**
     * Generic delete
     *
     * @param con Connection
     * @param table table name
     * @param whereColumn
     * @param equalsTo
     * @param log Logger (cannot be null)
     *
     * @return null if failed or true if success
     */
    public static Boolean genericDelete(
            Connection con, String table, String whereColumn, String equalsTo,
            Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, whereColumn)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        }

        final String insertQuery = String.format(
                "DELETE FROM %s WHERE %s=?;", table, whereColumn);
        try {
            PreparedStatement stm = con.prepareStatement(insertQuery);

            stm.setString(1, encode(equalsTo));

            boolean b = (stm.executeUpdate() > 0);

            stm.close();

            return b;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
            ex.printStackTrace();
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
            e.printStackTrace();
        }
        return null;
    }

    public static Boolean genericDelete(Connection con, String table, Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        }

        final String insertQuery = String.format(
                "DELETE FROM %s;", table);
        try {
            PreparedStatement stm = con.prepareStatement(insertQuery);

            boolean b = (stm.executeUpdate() > 0);

            stm.close();

            return b;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
            ex.printStackTrace();
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Generic delete
     *
     * @param con Connection
     * @param table table name
     * @param whereColumn1
     * @param equalsTo1
     * @param whereColumn2
     * @param equalsTo2
     * @param log Logger (cannot be null)
     *
     * @return null if failed or true if success
     */
    public static Boolean genericDelete(
            Connection con, String table, String whereColumn1, String equalsTo1,
            String whereColumn2, String equalsTo2,
            Logger log) {

        if (log == null) {
            return null; // whoa
        } else if (con == null) {
            log.error(EXCEPTION_TAG + DB_FAIL);
            return null;
        } else if (isBad(table, whereColumn1, whereColumn2)) {
            log.error(EXCEPTION_TAG + COLUMNTABLE_FAIL);
            return null;
        }

        final String insertQuery = String.format(
                "DELETE FROM %s WHERE %s=? AND %s=?;", table, whereColumn1,
                whereColumn2);
        try {
            PreparedStatement stm = con.prepareStatement(insertQuery);

            stm.setString(1, encode(equalsTo1));
            stm.setString(2, encode(equalsTo2));

            boolean b = (stm.executeUpdate() > 0);

            stm.close();

            return b;
        } catch (SQLException ex) {
            log.error(EXCEPTION_TAG + INVALID_SQL);
        } catch (Exception e) {
            log.error(EXCEPTION_TAG + ANYERROR_FAIL);
        }
        return null;
    }

    /**
     * generate a delete query
     *
     * @param table table name
     * @param whereColumns columns list
     *
     * @return null if failed or true if success
     */
    public static String buildQueryStringDelete(
            String table, String[] whereColumns) {

        if (isBad(table) || isBadArr(whereColumns)) {
            return null;
        }

        final StringBuilder sb = new StringBuilder(whereColumns[0]);
        sb.append("=? ");
        for (int i = 1; i < whereColumns.length; i++) {
            sb.append(" AND").append(whereColumns[i]).append("=? ");
        }

        final String insertQuery = String.format(
                "DELETE FROM %s WHERE %s;", table, sb.toString());

        return insertQuery;
    }

    /**
     * generate a select query
     *
     * @param table table name
     * @param whereColumns columns list
     * @param whatColumns
     *
     * @return null if failed or true if success
     */
    public static String buildQueryStringSelect(
            String table, String[] whereColumns, String[] whatColumns) {

        if (isBad(table) || isBadArr(whereColumns) || isBadArr(whatColumns)) {
            return null;
        }

        final StringBuilder sbWhere = new StringBuilder(whereColumns[0]);
        sbWhere.append("=? ");
        for (int i = 1; i < whereColumns.length; i++) {
            sbWhere.append(" AND").append(whereColumns[i]).append("=? ");
        }

        final String insertQuery = String.format(
                "SELECT %s FROM %s WHERE %s;", String.join(",", whatColumns),
                table, sbWhere.toString());

        return insertQuery;
    }

    /**
     * generate a select query
     *
     * @param table table name
     * @param whatColumns columns list
     *
     * @return null if failed or true if success
     */
    public static String buildQueryStringSelect(
            String table, String[] whatColumns) {

        if (isBad(table) || isBadArr(whatColumns)) {
            return null;
        }

        final String insertQuery = String.format(
                "SELECT %s FROM %s;", String.join(",", whatColumns),
                table);

        return insertQuery;
    }

    /**
     * generate a select all query
     *
     * @param table name of the table
     * @param where where column name to equals
     * @return query
     */
    public static String buildQueryStringSelect(String table, String where) {
        if (isBad(table, where)) {
            return null;
        }

        final String insertQuery = String.format(
                "SELECT * FROM %s WHERE %s=?;", table, where);

        return insertQuery;
    }

    /**
     * create a key value map from a database
     *
     * @param con connection
     * @param tableName table name
     * @param keyColumn key column
     * @param valColumn value column
     * @param log logger
     * @return map
     */
    private static HashMap<String, String> createDataMap(Connection con,
            String tableName,
            String keyColumn, String valColumn, Logger log) {
        ArrayList<ArrayList<String>> data = genericSelectStrings(
                con, tableName, new String[]{keyColumn, valColumn}, log);

        HashMap<String, String> map = new HashMap<>();
        if (data != null) {
            for (ArrayList<String> l : data) {
                map.put(l.get(0), l.get(1));
            }
        }

        return map;
    }

}
